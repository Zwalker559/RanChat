/**
 * @file firestore.rules
 * @description Firestore security rules for the RanChat application.
 *
 * @section Core Philosophy
 * This ruleset enforces a security model centered on user ownership and explicit sharing.
 * User-specific data is stored within a user's own document tree, making it private by default.
 * Shared data, such as chat sessions, relies on denormalized participant IDs within documents
 * to grant access to a specific, closed set of collaborators.
 *
 * @section Data Structure
 * - /users/{userId}: Private user profile data. Each user owns their document.
 * - /users/{userId}/chat_sessions/{chatSessionId}: Chat metadata. Access is shared between the two participants.
 * - /users/{userId}/chat_sessions/{chatSessionId}/messages/{messageId}: Individual chat messages. Access is inherited from the parent chat session.
 * - /active_users/{userId}: Publicly readable presence information, but writable only by the owner.
 *
 * @section Key Security Decisions
 * - User Isolation: Users cannot read, list, or modify another user's private data in the `/users` collection.
 * - Shared Chat Access: Access to chat sessions and messages is granted if the user's ID is one of the two participants (`user1Id`, `user2Id`) listed in the parent ChatSession document. This avoids complex queries and ensures privacy.
 * - Public Presence: The `/active_users` collection is readable by any signed-in user to facilitate a "who's online" feature, but each user can only manage their own presence document.
 * - Default Deny: All paths not explicitly matched are denied access.
 *
 * @section Denormalization for Authorization
 * To create performant and secure rules, authorization data is denormalized:
 * - ChatSession documents contain `user1Id` and `user2Id` fields directly. This allows rules to check for participation without needing slow and costly `get` or `exists` calls to other collections.
 * - Rules for subcollections (like `/messages`) use a `get()` call on the parent document to securely inherit its access permissions.
 *
 * @section Structural Segregation
 * - Private user data is structurally segregated under `/users/{userId}`.
 * - Publicly readable presence data is in a separate top-level collection, `/active_users`, which prevents accidental exposure of private data through list queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists before an operation.
     */
    function documentExists() {
      return resource != null;
    }

    /**
     * Verifies ownership for an existing document (for update/delete).
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && documentExists();
    }
    
    /**
     * Checks if the requesting user is one of the two participants in a chat session document.
     * @param chatSession The resource.data of a ChatSession document.
     */
    function isChatParticipant(chatSession) {
      return isSignedIn() && (request.auth.uid == chatSession.user1Id || request.auth.uid == chatSession.user2Id);
    }

    /**
     * Fetches the parent ChatSession document and checks if the requesting user is a participant.
     * This is used to secure subcollections like 'messages'.
     */
    function isParticipantOfParentSession(userId, chatSessionId) {
      let sessionDoc = get(/databases/$(database)/documents/users/$(userId)/chat_sessions/$(chatSessionId));
      return sessionDoc != null && isChatParticipant(sessionDoc.data);
    }
    
    /**
     * Validates the required user ID field on document creation.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Ensures the user ID field cannot be changed after creation.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Validates ChatSession data on creation. Ensures the creator is user1,
     * the document ID matches the path, and the path's userId is a participant.
     */
    function hasValidChatSessionDataOnCreate(userId, chatSessionId) {
      let data = request.resource.data;
      return data.id == chatSessionId &&
             data.user1Id == request.auth.uid &&
             (userId == data.user1Id || userId == data.user2Id);
    }
    
    /**
     * Validates ChatMessage data on creation, linking it to the sender and parent session.
     */
    function hasValidChatMessageDataOnCreate(chatSessionId) {
      let data = request.resource.data;
      return data.senderId == request.auth.uid &&
             data.chatSessionId == chatSessionId;
    }


    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) A new user creating their own profile document. auth.uid must match userId.
     * @allow (get, update, delete) The user accessing or modifying their own profile.
     * @deny (list) Any user trying to list all user profiles.
     * @deny (get, update, delete) A user trying to access another user's profile.
     * @principle Restricts access to a user's own data tree (Ownership).
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages chat sessions between two users.
       * @path /users/{userId}/chat_sessions/{chatSessionId}
       * @allow (get, list, delete) A user who is a participant of the chat session.
       * @allow (create) An authenticated user creating a new session where they are `user1Id`.
       * @deny (get) A user trying to read a chat session they are not a part of.
       * @deny (update) Chat sessions are immutable after creation.
       * @principle Enforces access control for a closed set of collaborators (Shared Access).
       */
      match /chat_sessions/{chatSessionId} {
        allow get: if isChatParticipant(resource.data);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidChatSessionDataOnCreate(userId, chatSessionId);
        allow update: if false;
        allow delete: if documentExists() && isChatParticipant(resource.data);

        /**
         * @description Manages messages within a chat session.
         * @path /users/{userId}/chat_sessions/{chatSessionId}/messages/{messageId}
         * @allow (get, list) Any participant of the parent chat session.
         * @allow (create) A participant of the parent chat session sending a message.
         * @deny (get, list) A user trying to read messages in a session they are not part of.
         * @deny (update, delete) Messages are immutable.
         * @principle Inherits access permissions from a parent document using get().
         */
        match /messages/{messageId} {
          allow get: if isParticipantOfParentSession(userId, chatSessionId);
          allow list: if isParticipantOfParentSession(userId, chatSessionId);
          allow create: if isParticipantOfParentSession(userId, chatSessionId) && hasValidChatMessageDataOnCreate(chatSessionId);
          allow update: if false;
          allow delete: if false;
        }
      }
    }
    
    /**
     * @description Stores online presence for active users. Data is public for reads.
     * @path /active_users/{userId}
     * @allow (get, list) Any authenticated user can see who is online.
     * @allow (create, update, delete) A user can only manage their own presence document.
     * @deny (create, update, delete) A user trying to modify another user's presence.
     * @principle Implements public read access with owner-only writes.
     */
    match /active_users/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);
    }
  }
}